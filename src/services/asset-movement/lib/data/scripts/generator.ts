import { compile } from 'json-schema-to-typescript';
import type { JSONSchema4 } from 'json-schema';
import { sharedJSONSchemaTypes, sharedSchemaReferences } from '../types.js';
import fs from 'fs';
import { definitions } from '../addresses/index.generated.js';

function firstCharUpper(str: string): string {
	if (str.length === 0) {
		return(str);
	}

	return(str.charAt(0).toUpperCase() + str.slice(1));
}

function toCamelCase(str: string): string {
	const split = str.split(/[-_]/g);

	const mapped = split.map(function(part) {
		return(firstCharUpper(part));
	});

	return(mapped.join(''));
}

async function compileToString(schema: JSONSchema4, name: string): Promise<string> {
	return(await compile(schema, name, {
		additionalProperties: false,
		bannerComment: ''
	}));
}

function parseArgs(argv: string[]): { typesOutput: string } {
	let typesOutput: string | undefined = undefined;
	for (const arg of argv) {
		if (arg.startsWith('--types-output=')) {
			typesOutput = arg.substring('--types-output='.length);
		}
	}

	if (!typesOutput?.endsWith('.ts')) {
		throw(new Error('Missing or invalid required argument: --types-output=path/to/types.generated.ts'));
	}
	return({
		typesOutput
	});
}

(async function() {
	const config = parseArgs(process.argv.slice(2));

	const out = [];

	out.push('// This file is generated by src/services/asset-movement/lib/data/scripts/generator.ts - do not edit');

	out.push('import type { ISOCountryCode } from "@keetanetwork/currency-info";');

	const allObfuscatedNames = [];
	const allResolvedNames = [];

	const allDefinitions: { [key: string]: JSONSchema4 } = {
		ISOCountryCode: sharedJSONSchemaTypes.ISOCountryCode,
		ObfuscatedAccountOwner: sharedJSONSchemaTypes.ObfuscatedAccountOwner,
		ResolvedAccountOwner: sharedJSONSchemaTypes.ResolvedAccountOwner,
		PhysicalAddress: sharedJSONSchemaTypes.PhysicalAddress,
		PhoneNumber: sharedJSONSchemaTypes.PhoneNumber
	};

	for (const [ name, schema ] of Object.entries(definitions)) {
		for (const value of [ 'resolved', 'obfuscated' ] as const) {
			const interfaceName = toCamelCase(`${name}_${value}`);

			const allOfIncludes: JSONSchema4[] = [];

			if (schema.includeFields.accountOwner) {
				if (value === 'resolved') {
					allOfIncludes.push(sharedSchemaReferences.ResolvedAccountOwner);
				} else {
					allOfIncludes.push(sharedSchemaReferences.ObfuscatedAccountOwner);
				}
			}

			if (schema.includeFields.bankName) {
				allOfIncludes.push({
					type: 'object',
					properties: {
						bankName: { type: 'string' }
					}
				});
			}

			allDefinitions[interfaceName] = {
				allOf: [
					schema.additionalProperties[value],
					{
						type: 'object',
						properties: {
							type: { const: 'bank-account' },
							accountType: { const: name },
							obfuscated: { const: value === 'obfuscated' }

						},
						required: [
							'type', 'accountType',
							...(value === 'resolved' ? [] : ['obfuscated'])
						]
					},
					...allOfIncludes
				]
			};

			if (value === 'resolved') {
				allResolvedNames.push(interfaceName);
			} else {
				allObfuscatedNames.push(interfaceName);
			}
		}
	}

	allDefinitions['BankAccountAddressResolved'] = {
		oneOf: allResolvedNames.map((name) => ({ $ref: `#/definitions/${name}` }))
	};

	allDefinitions['BankAccountAddressObfuscated'] = {
		oneOf: allObfuscatedNames.map((name) => ({ $ref: `#/definitions/${name}` }))
	};


	const jsonSchemaDefinitions = { definitions: allDefinitions };

	const compiled = await compileToString({
		...jsonSchemaDefinitions,
		oneOf: Object.keys(allDefinitions).map((name) => ({ $ref: `#/definitions/${name}` }))
	}, 'TempType');

	const compiledWithoutTemp = compiled.replaceAll(/export type (TempType|ISOCountryCode) =([\w\n |'"]+);\n/gm, '');
	out.push(compiledWithoutTemp);

	const schema = JSON.stringify(jsonSchemaDefinitions, null, 2);
	out.push(`export const accountJSONSchema = ${schema} as const;`);

	fs.writeFileSync(config.typesOutput, out.join('\n'));
})().catch(function(err: unknown) {
	console.error(err);
	process.exit(1);
});

